---
export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  className?: string;
  loading?: 'lazy' | 'eager';
  placeholder?: string;
  sizes?: string;
  quality?: number;
  format?: 'webp' | 'jpg' | 'png' | 'avif';
}

const { 
  src, 
  alt, 
  width, 
  height, 
  className = '', 
  loading = 'lazy',
  placeholder,
  sizes,
  quality = 80,
  format = 'webp'
} = Astro.props;

// Generate placeholder if not provided
const defaultPlaceholder = `data:image/svg+xml;base64,${btoa(
  `<svg width="${width || 300}" height="${height || 200}" xmlns="http://www.w3.org/2000/svg">
    <rect width="100%" height="100%" fill="#f3f4f6"/>
    <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif" font-size="14" fill="#9ca3af">
      Loading...
    </text>
  </svg>`
)}`;

const placeholderSrc = placeholder || defaultPlaceholder;
---

<div class={`lazy-image-container ${className}`}>
  <img 
    class="lazy-image"
    src={placeholderSrc}
    data-src={src}
    alt={alt}
    width={width}
    height={height}
    loading={loading}
    sizes={sizes}
    style={`aspect-ratio: ${width && height ? `${width}/${height}` : 'auto'};`}
  />
  <noscript>
    <img src={src} alt={alt} width={width} height={height} />
  </noscript>
</div>

<script>
  // Intersection Observer for lazy loading
  const imageObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target as HTMLImageElement;
        const actualSrc = img.dataset.src;
        
        if (actualSrc) {
          // Create a new image to preload
          const newImg = new Image();
          newImg.onload = () => {
            // Smooth transition
            img.style.opacity = '0';
            setTimeout(() => {
              img.src = actualSrc;
              img.style.opacity = '1';
              img.classList.add('loaded');
            }, 150);
          };
          newImg.onerror = () => {
            img.classList.add('error');
          };
          newImg.src = actualSrc;
          
          observer.unobserve(img);
        }
      }
    });
  }, {
    rootMargin: '50px 0px',
    threshold: 0.01
  });

  // Observe all lazy images
  document.addEventListener('DOMContentLoaded', () => {
    const lazyImages = document.querySelectorAll('.lazy-image');
    lazyImages.forEach(img => imageObserver.observe(img));
  });

  // Handle dynamic content
  const mutationObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === 1) { // Element node
          const element = node as Element;
          const lazyImages = element.querySelectorAll('.lazy-image');
          lazyImages.forEach(img => imageObserver.observe(img));
        }
      });
    });
  });

  mutationObserver.observe(document.body, {
    childList: true,
    subtree: true
  });
</script>

<style>
  .lazy-image-container {
    overflow: hidden;
    background: var(--color-bg-tertiary);
    border-radius: var(--radius-base);
  }

  .lazy-image {
    width: 100%;
    height: auto;
    transition: opacity 0.3s ease;
    object-fit: cover;
    background: var(--color-bg-tertiary);
  }

  .lazy-image.loaded {
    opacity: 1;
  }

  .lazy-image.error {
    opacity: 0.5;
    filter: grayscale(1);
  }

  /* Blur-up effect for placeholder */
  .lazy-image:not(.loaded) {
    filter: blur(5px);
    transform: scale(1.05);
  }

  /* Reduce motion for accessibility */
  @media (prefers-reduced-motion: reduce) {
    .lazy-image {
      transition: none;
      filter: none;
      transform: none;
    }
  }
</style>