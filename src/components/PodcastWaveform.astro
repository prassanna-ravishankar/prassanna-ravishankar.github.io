---
export interface Props {
  title: string;
  duration: string;
  description: string;
  url: string;
  date: string;
  featured?: boolean;
  audioUrl?: string;
  episodeNumber?: number;
  season?: number;
}

const { title, duration, description, url, date, featured, audioUrl, episodeNumber, season } = Astro.props;
const hasAudio = audioUrl && audioUrl.startsWith('http');
---

<div class="podcast-waveform-container" data-featured={featured}>
  <div class="podcast-info">
    <div class="episode-meta">
      {episodeNumber && season && (
        <span class="episode-number">S{season}E{episodeNumber}</span>
      )}
      <span class="episode-date">{date}</span>
      <span class="episode-duration">{duration}</span>
      {featured && <span class="featured-badge">Featured</span>}
    </div>
    
    <h3 class="episode-title">
      <a href={url} class="title-link">{title}</a>
    </h3>
    
    <p class="episode-description">{description}</p>
  </div>
  
  <div class="waveform-container">
    <canvas class="waveform-canvas" width="400" height="80"></canvas>
    <div class="waveform-controls">
      {hasAudio ? (
        <button class="play-btn" data-audio-url={audioUrl}>
          <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"/>
          </svg>
          <svg class="pause-icon hidden" viewBox="0 0 24 24" fill="currentColor">
            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
          </svg>
        </button>
      ) : (
        <div class="play-btn disabled">
          <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"/>
          </svg>
        </div>
      )}
      
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress-fill"></div>
          <div class="progress-handle"></div>
        </div>
        <div class="time-display">
          <span class="current-time">0:00</span>
          <span class="total-time">{duration}</span>
        </div>
      </div>
      
      <div class="volume-control">
        <svg class="volume-icon" viewBox="0 0 24 24" fill="currentColor">
          <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3A4.5 4.5 0 0014 7.97v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
        <input type="range" class="volume-slider" min="0" max="1" step="0.1" value="0.7">
      </div>
    </div>
  </div>
  
  <div class="episode-actions">
    <a href={url} class="action-link primary">
      <svg class="action-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
      </svg>
      View Episode
    </a>
    
    <button class="action-link secondary share-btn" data-title={title} data-url={url}>
      <svg class="action-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z"/>
      </svg>
      Share
    </button>
  </div>
  
  {hasAudio && (
    <audio class="audio-element" preload="none">
      <source src={audioUrl} type="audio/mpeg" />
    </audio>
  )}
  
  {!hasAudio && (
    <div class="no-audio-message">
      <svg class="info-icon" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
      </svg>
      <span>Visit podcast platforms to listen</span>
    </div>
  )}
</div>

<script>
  class PodcastWaveform {
    constructor(container) {
      this.container = container;
      this.canvas = container.querySelector('.waveform-canvas');
      this.ctx = this.canvas.getContext('2d');
      this.playBtn = container.querySelector('.play-btn');
      this.progressBar = container.querySelector('.progress-bar');
      this.progressFill = container.querySelector('.progress-fill');
      this.progressHandle = container.querySelector('.progress-handle');
      this.currentTimeEl = container.querySelector('.current-time');
      this.volumeSlider = container.querySelector('.volume-slider');
      this.shareBtn = container.querySelector('.share-btn');
      this.audioElement = container.querySelector('.audio-element');
      
      this.isPlaying = false;
      this.currentTime = 0;
      this.duration = 0;
      this.volume = 0.7;
      this.waveformData = this.generateWaveformData();
      this.hasRealAudio = this.audioElement && this.playBtn?.dataset.audioUrl;
      
      this.colors = {
        waveform: '#3b82f6',
        waveformPlayed: '#10b981',
        background: '#f1f5f9',
        progress: '#3b82f6'
      };
      
      this.init();
    }
    
    init() {
      this.drawWaveform();
      this.setupEventListeners();
      this.updateColors();
      
      // Setup audio if available
      if (this.hasRealAudio) {
        this.setupAudio();
      } else {
        // Parse duration from display text for visual-only mode
        const durationText = this.container.querySelector('.episode-duration')?.textContent || '0:00';
        this.duration = this.parseDuration(durationText);
      }
      
      // Animate waveform on load
      this.animateWaveformLoad();
    }
    
    setupAudio() {
      this.audioElement.volume = this.volume;
      
      // Audio event listeners
      this.audioElement.addEventListener('loadedmetadata', () => {
        this.duration = this.audioElement.duration;
        this.container.querySelector('.total-time').textContent = this.formatTime(this.duration);
      });
      
      this.audioElement.addEventListener('timeupdate', () => {
        this.currentTime = this.audioElement.currentTime;
        this.updateProgress();
        this.drawWaveform();
      });
      
      this.audioElement.addEventListener('ended', () => {
        this.isPlaying = false;
        this.updatePlayButton();
        this.currentTime = 0;
        this.updateProgress();
        this.drawWaveform();
      });
      
      this.audioElement.addEventListener('error', () => {
        this.showError();
      });
    }
    
    showError() {
      const controls = this.container.querySelector('.waveform-controls');
      if (controls) {
        controls.innerHTML = `
          <div class="audio-error">
            <span>⚠️ Audio unavailable - Visit podcast platforms to listen</span>
          </div>
        `;
      }
    }
    
    updateColors() {
      const isDark = document.documentElement.classList.contains('dark');
      if (isDark) {
        this.colors.background = '#374151';
        this.colors.waveform = '#60a5fa';
        this.colors.waveformPlayed = '#34d399';
      }
    }
    
    generateWaveformData() {
      // Generate realistic-looking waveform data
      const dataPoints = 200;
      const data = [];
      
      for (let i = 0; i < dataPoints; i++) {
        // Create natural-looking audio waveform with varying amplitudes
        const base = Math.sin(i * 0.02) * 0.3;
        const variation = Math.random() * 0.7;
        const speech = Math.sin(i * 0.1) * 0.4;
        
        data.push(Math.max(0.1, Math.min(1, base + variation + speech)));
      }
      
      return data;
    }
    
    drawWaveform() {
      const width = this.canvas.width;
      const height = this.canvas.height;
      const barWidth = width / this.waveformData.length;
      
      this.ctx.clearRect(0, 0, width, height);
      
      // Background
      this.ctx.fillStyle = this.colors.background;
      this.ctx.fillRect(0, 0, width, height);
      
      // Draw waveform bars
      this.waveformData.forEach((amplitude, index) => {
        const x = index * barWidth;
        const barHeight = amplitude * height * 0.8;
        const y = (height - barHeight) / 2;
        
        // Determine if this bar should be "played" color
        const progress = this.currentTime / this.duration;
        const isPlayed = index / this.waveformData.length < progress;
        
        this.ctx.fillStyle = isPlayed ? this.colors.waveformPlayed : this.colors.waveform;
        this.ctx.fillRect(x, y, Math.max(1, barWidth - 1), barHeight);
        
        // Add glow effect for currently playing area
        if (isPlayed && this.isPlaying) {
          this.ctx.shadowBlur = 10;
          this.ctx.shadowColor = this.colors.waveformPlayed;
          this.ctx.fillRect(x, y, Math.max(1, barWidth - 1), barHeight);
          this.ctx.shadowBlur = 0;
        }
      });
      
      // Draw progress indicator
      if (this.isPlaying) {
        const progressX = (this.currentTime / this.duration) * width;
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(progressX, 0);
        this.ctx.lineTo(progressX, height);
        this.ctx.stroke();
      }
    }
    
    animateWaveformLoad() {
      let frame = 0;
      const totalFrames = 60;
      
      const animate = () => {
        frame++;
        
        // Animate bars growing from center
        const progress = frame / totalFrames;
        const easeOutQuart = 1 - Math.pow(1 - progress, 4);
        
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Background
        this.ctx.fillStyle = this.colors.background;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        const barWidth = width / this.waveformData.length;
        
        this.waveformData.forEach((amplitude, index) => {
          const x = index * barWidth;
          const fullBarHeight = amplitude * height * 0.8;
          const barHeight = fullBarHeight * easeOutQuart;
          const y = (height - barHeight) / 2;
          
          this.ctx.fillStyle = this.colors.waveform;
          this.ctx.fillRect(x, y, Math.max(1, barWidth - 1), barHeight);
        });
        
        if (frame < totalFrames) {
          requestAnimationFrame(animate);
        } else {
          this.drawWaveform();
        }
      };
      
      animate();
    }
    
    setupEventListeners() {
      // Play/pause button
      this.playBtn.addEventListener('click', () => this.togglePlayback());
      
      // Waveform click to seek
      this.canvas.addEventListener('click', (e) => this.handleWaveformClick(e));
      
      // Progress bar interactions
      this.progressBar.addEventListener('click', (e) => this.handleProgressClick(e));
      
      // Volume control
      this.volumeSlider?.addEventListener('input', (e) => {
        this.volume = parseFloat(e.target.value);
        if (this.hasRealAudio) {
          this.audioElement.volume = this.volume;
        }
      });
      
      // Share button
      this.shareBtn?.addEventListener('click', () => this.handleShare());
      
      // Dark mode observer
      const observer = new MutationObserver(() => {
        this.updateColors();
        this.drawWaveform();
      });
      observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
    }
    
    togglePlayback() {
      if (this.playBtn.classList.contains('disabled')) return;
      
      this.isPlaying = !this.isPlaying;
      
      if (this.hasRealAudio) {
        if (this.isPlaying) {
          this.audioElement.play().catch(() => {
            this.isPlaying = false;
            this.showError();
          });
        } else {
          this.audioElement.pause();
        }
      } else {
        // Simulated playback for visual-only mode
        if (this.isPlaying) {
          this.startSimulatedPlayback();
        } else {
          this.stopSimulatedPlayback();
        }
      }
      
      this.updatePlayButton();
    }
    
    updatePlayButton() {
      const playIcon = this.playBtn.querySelector('.play-icon');
      const pauseIcon = this.playBtn.querySelector('.pause-icon');
      
      if (this.isPlaying) {
        playIcon?.classList.add('hidden');
        pauseIcon?.classList.remove('hidden');
      } else {
        playIcon?.classList.remove('hidden');
        pauseIcon?.classList.add('hidden');
      }
    }
    
    startSimulatedPlayback() {
      this.playbackInterval = setInterval(() => {
        this.currentTime += 0.1;
        
        if (this.currentTime >= this.duration) {
          this.currentTime = this.duration;
          this.isPlaying = false;
          this.updatePlayButton();
          clearInterval(this.playbackInterval);
          return;
        }
        
        this.updateProgress();
        this.drawWaveform();
      }, 100);
    }
    
    stopSimulatedPlayback() {
      if (this.playbackInterval) {
        clearInterval(this.playbackInterval);
      }
    }
    
    updateProgress() {
      const progress = this.currentTime / this.duration;
      this.progressFill.style.width = `${progress * 100}%`;
      this.progressHandle.style.left = `${progress * 100}%`;
      
      this.currentTimeEl.textContent = this.formatTime(this.currentTime);
    }
    
    handleWaveformClick(e) {
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const progress = x / rect.width;
      
      if (this.hasRealAudio) {
        this.audioElement.currentTime = progress * this.duration;
      } else {
        this.currentTime = progress * this.duration;
        this.updateProgress();
        this.drawWaveform();
      }
    }
    
    handleProgressClick(e) {
      const rect = this.progressBar.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const progress = x / rect.width;
      
      if (this.hasRealAudio) {
        this.audioElement.currentTime = progress * this.duration;
      } else {
        this.currentTime = progress * this.duration;
        this.updateProgress();
        this.drawWaveform();
      }
    }
    
    handleShare() {
      const title = this.shareBtn.dataset.title;
      const url = this.shareBtn.dataset.url;
      
      if (navigator.share) {
        navigator.share({
          title: title,
          url: url
        });
      } else {
        // Fallback to clipboard
        navigator.clipboard.writeText(url).then(() => {
          // Show toast notification
          this.showToast('Episode link copied to clipboard!');
        });
      }
    }
    
    showToast(message) {
      const toast = document.createElement('div');
      toast.className = 'toast-notification';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.classList.add('show');
      }, 100);
      
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => document.body.removeChild(toast), 300);
      }, 3000);
    }
    
    parseDuration(durationStr) {
      const parts = durationStr.split(':').map(p => parseInt(p));
      if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
      } else if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
      }
      return 0;
    }
    
    formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
  }
  
  // Initialize all podcast waveforms
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.podcast-waveform-container').forEach(container => {
      new PodcastWaveform(container);
    });
  });
</script>

<style>
  .podcast-waveform-container {
    background: white;
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    border: 1px solid #e5e7eb;
    transition: all 0.3s ease;
    margin-bottom: 1.5rem;
  }
  
  .podcast-waveform-container:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.1);
  }
  
  .dark .podcast-waveform-container {
    background: #1f2937;
    border-color: #374151;
  }
  
  .podcast-waveform-container[data-featured="true"] {
    border: 2px solid #3b82f6;
    background: linear-gradient(135deg, 
      rgba(59, 130, 246, 0.05), 
      rgba(99, 102, 241, 0.02)
    );
  }
  
  .dark .podcast-waveform-container[data-featured="true"] {
    background: linear-gradient(135deg, 
      rgba(59, 130, 246, 0.1), 
      rgba(99, 102, 241, 0.05)
    );
  }
  
  .podcast-info {
    margin-bottom: 1.5rem;
  }
  
  .episode-meta {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 0.75rem;
    flex-wrap: wrap;
  }
  
  .episode-date {
    color: #6b7280;
    font-size: 0.875rem;
    font-weight: 500;
  }
  
  .dark .episode-date {
    color: #9ca3af;
  }
  
  .episode-duration {
    background: #3b82f6;
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 600;
  }
  
  .featured-badge {
    background: linear-gradient(45deg, #fbbf24, #f59e0b);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 600;
  }
  
  .episode-title {
    margin: 0 0 0.75rem 0;
    font-size: 1.25rem;
    font-weight: 700;
    line-height: 1.4;
  }
  
  .title-link {
    color: #1f2937;
    text-decoration: none;
    transition: color 0.2s ease;
  }
  
  .title-link:hover {
    color: #3b82f6;
  }
  
  .dark .title-link {
    color: #f9fafb;
  }
  
  .dark .title-link:hover {
    color: #60a5fa;
  }
  
  .episode-description {
    color: #6b7280;
    line-height: 1.6;
    margin: 0;
  }
  
  .dark .episode-description {
    color: #9ca3af;
  }
  
  .waveform-container {
    background: #f8fafc;
    border-radius: 12px;
    padding: 1rem;
    margin-bottom: 1rem;
  }
  
  .dark .waveform-container {
    background: #374151;
  }
  
  .waveform-canvas {
    width: 100%;
    height: 80px;
    border-radius: 8px;
    cursor: pointer;
    margin-bottom: 1rem;
  }
  
  .waveform-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  
  .play-btn {
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    background: linear-gradient(45deg, #3b82f6, #6366f1);
    border: none;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }
  
  .play-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 14px rgba(59, 130, 246, 0.3);
  }
  
  .play-btn.disabled {
    background: #9ca3af;
    cursor: not-allowed;
    opacity: 0.6;
  }
  
  .play-btn.disabled:hover {
    transform: none;
    box-shadow: none;
  }
  
  .play-icon, .pause-icon {
    width: 1.25rem;
    height: 1.25rem;
  }
  
  .progress-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .progress-bar {
    position: relative;
    height: 6px;
    background: #e5e7eb;
    border-radius: 3px;
    cursor: pointer;
  }
  
  .dark .progress-bar {
    background: #4b5563;
  }
  
  .progress-fill {
    height: 100%;
    background: linear-gradient(45deg, #3b82f6, #6366f1);
    border-radius: 3px;
    width: 0%;
    transition: width 0.1s ease;
  }
  
  .progress-handle {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 12px;
    height: 12px;
    background: white;
    border: 2px solid #3b82f6;
    border-radius: 50%;
    left: 0%;
    cursor: pointer;
    transition: left 0.1s ease;
  }
  
  .time-display {
    display: flex;
    justify-content: between;
    font-size: 0.75rem;
    color: #6b7280;
    font-family: monospace;
  }
  
  .dark .time-display {
    color: #9ca3af;
  }
  
  .volume-control {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-shrink: 0;
  }
  
  .volume-icon {
    width: 1.25rem;
    height: 1.25rem;
    color: #6b7280;
  }
  
  .dark .volume-icon {
    color: #9ca3af;
  }
  
  .volume-slider {
    width: 80px;
    accent-color: #3b82f6;
  }
  
  .episode-actions {
    display: flex;
    gap: 0.75rem;
  }
  
  .action-link {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 500;
    transition: all 0.2s ease;
    border: none;
    cursor: pointer;
    font-size: 0.875rem;
  }
  
  .action-link.primary {
    background: #3b82f6;
    color: white;
  }
  
  .action-link.primary:hover {
    background: #2563eb;
    transform: translateY(-1px);
  }
  
  .action-link.secondary {
    background: rgba(59, 130, 246, 0.1);
    color: #3b82f6;
    border: 1px solid rgba(59, 130, 246, 0.2);
  }
  
  .action-link.secondary:hover {
    background: rgba(59, 130, 246, 0.2);
  }
  
  .action-icon {
    width: 1rem;
    height: 1rem;
  }
  
  .hidden {
    display: none;
  }
  
  .toast-notification {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    font-size: 0.875rem;
    z-index: 1000;
    transform: translateY(100px);
    opacity: 0;
    transition: all 0.3s ease;
    backdrop-filter: blur(4px);
  }
  
  .toast-notification.show {
    transform: translateY(0);
    opacity: 1;
  }
  
  .episode-number {
    font-size: 0.75rem;
    color: #3b82f6;
    background: rgba(59, 130, 246, 0.1);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-weight: 600;
    margin-right: 0.5rem;
  }
  
  .dark .episode-number {
    background: rgba(59, 130, 246, 0.2);
    color: #60a5fa;
  }
  
  .no-audio-message,
  .audio-error {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    background: #fef3c7;
    border: 1px solid #fbbf24;
    border-radius: 8px;
    color: #92400e;
    font-size: 0.875rem;
    margin-top: 1rem;
  }
  
  .dark .no-audio-message,
  .dark .audio-error {
    background: rgba(251, 191, 36, 0.1);
    border-color: rgba(251, 191, 36, 0.3);
    color: #fbbf24;
  }
  
  .info-icon {
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
  }
  
  /* Responsive adjustments */
  @media (max-width: 640px) {
    .waveform-controls {
      flex-direction: column;
      gap: 1rem;
      align-items: stretch;
    }
    
    .progress-container {
      order: -1;
    }
    
    .volume-control {
      justify-content: center;
    }
    
    .episode-actions {
      flex-direction: column;
    }
  }
</style>