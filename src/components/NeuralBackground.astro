---
// Neural Network Background Component
---

<div id="neural-background" class="absolute inset-0 overflow-hidden">
  <div id="neural-loading" class="neural-loading">
    <div class="neural-loading-dots">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>
  <canvas id="neural-canvas" class="w-full h-full opacity-0"></canvas>
</div>

<script>
  class NeuralNetwork {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.nodes = [];
      this.connections = [];
      this.animationId = null;
      
      this.resize();
      this.init();
      
      // Hide loading and show canvas after initialization
      setTimeout(() => {
        const loading = document.getElementById('neural-loading');
        const canvas = document.getElementById('neural-canvas');
        if (loading) loading.style.display = 'none';
        if (canvas) canvas.style.opacity = '1';
        this.animate();
      }, 500);
      
      window.addEventListener('resize', () => this.resize());
    }
    
    resize() {
      this.canvas.width = this.canvas.offsetWidth * window.devicePixelRatio;
      this.canvas.height = this.canvas.offsetHeight * window.devicePixelRatio;
      this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      this.canvas.style.width = this.canvas.offsetWidth + 'px';
      this.canvas.style.height = this.canvas.offsetHeight + 'px';
    }
    
    init() {
      const nodeCount = Math.floor((this.canvas.offsetWidth * this.canvas.offsetHeight) / 15000);
      this.nodes = [];
      this.connections = [];
      
      // Create nodes
      for (let i = 0; i < nodeCount; i++) {
        this.nodes.push({
          x: Math.random() * this.canvas.offsetWidth,
          y: Math.random() * this.canvas.offsetHeight,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          radius: Math.random() * 2 + 1,
          alpha: Math.random() * 0.5 + 0.3,
          pulse: Math.random() * Math.PI * 2
        });
      }
      
      // Create connections
      for (let i = 0; i < this.nodes.length; i++) {
        for (let j = i + 1; j < this.nodes.length; j++) {
          const distance = this.getDistance(this.nodes[i], this.nodes[j]);
          if (distance < 120) {
            this.connections.push({
              node1: this.nodes[i],
              node2: this.nodes[j],
              distance: distance,
              alpha: 0.1
            });
          }
        }
      }
    }
    
    getDistance(node1, node2) {
      return Math.sqrt(Math.pow(node2.x - node1.x, 2) + Math.pow(node2.y - node1.y, 2));
    }
    
    animate() {
      this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight);
      
      // Update and draw nodes
      this.nodes.forEach(node => {
        // Update position
        node.x += node.vx;
        node.y += node.vy;
        
        // Bounce off edges
        if (node.x < 0 || node.x > this.canvas.offsetWidth) node.vx *= -1;
        if (node.y < 0 || node.y > this.canvas.offsetHeight) node.vy *= -1;
        
        // Update pulse
        node.pulse += 0.02;
        const pulseFactor = Math.sin(node.pulse) * 0.3 + 0.7;
        
        // Draw node
        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, node.radius * pulseFactor, 0, Math.PI * 2);
        this.ctx.fillStyle = `rgba(59, 130, 246, ${node.alpha * pulseFactor})`;
        this.ctx.fill();
        
        // Draw node glow
        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, node.radius * pulseFactor * 2, 0, Math.PI * 2);
        this.ctx.fillStyle = `rgba(59, 130, 246, ${node.alpha * 0.1 * pulseFactor})`;
        this.ctx.fill();
      });
      
      // Draw connections
      this.connections.forEach(connection => {
        const distance = this.getDistance(connection.node1, connection.node2);
        const alpha = Math.max(0, (120 - distance) / 120) * 0.15;
        
        if (alpha > 0) {
          this.ctx.beginPath();
          this.ctx.moveTo(connection.node1.x, connection.node1.y);
          this.ctx.lineTo(connection.node2.x, connection.node2.y);
          this.ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
          this.ctx.lineWidth = 1;
          this.ctx.stroke();
        }
      });
      
      this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      window.removeEventListener('resize', () => this.resize());
    }
  }
  
  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('neural-canvas');
    if (canvas) {
      new NeuralNetwork(canvas);
    }
  });
</script>

<style>
  #neural-background {
    opacity: 0.4;
    z-index: 0;
  }
  
  .dark #neural-background {
    opacity: 0.6;
  }
  
  #neural-canvas {
    display: block;
    transition: opacity 0.5s ease;
  }

  .neural-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1;
  }

  .neural-loading-dots {
    display: flex;
    gap: 8px;
  }

  .neural-loading-dots .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: rgba(59, 130, 246, 0.6);
    animation: neuralPulse 1.5s ease-in-out infinite;
  }

  .neural-loading-dots .dot:nth-child(2) {
    animation-delay: 0.2s;
  }

  .neural-loading-dots .dot:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes neuralPulse {
    0%, 80%, 100% {
      transform: scale(0.8);
      opacity: 0.3;
    }
    40% {
      transform: scale(1.2);
      opacity: 1;
    }
  }

  /* Reduce motion for accessibility */
  @media (prefers-reduced-motion: reduce) {
    .neural-loading-dots .dot {
      animation: none;
      opacity: 0.6;
    }
    #neural-canvas {
      transition: none;
    }
  }
</style>